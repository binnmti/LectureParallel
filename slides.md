---
theme: seriph
background: https://cover.sli.dev
title: Welcome to Slidev
info: |
  ## Slidev Starter Template
  Presentation slides for developers.

  Learn more at [Sli.dev](https://sli.dev)
class: text-center
highlighter: shiki
drawings:
  persist: false
transition: slide-left
mdc: true
---

<style>
h1 {
  background-color: #f0fff0;
  background-image: linear-gradient(45deg, #4EC5D4 10%, #146b8c 20%);
  background-size: 100%;
  -webkit-background-clip: text;
  -moz-background-clip: text;
  -webkit-text-fill-color: transparent;
  -moz-text-fill-color: transparent;
}
</style>

# 並行並列プログラミング

## 松井 敏

---

# 自己紹介

- 👨 松井 敏(まつい びん)
- 👜 Codeer プログラマ(本業) & HACARUS C#&CI/CD メンター(副業)
- 🏆 Microsoft MVP for Developer Technologies 2012-2024
- 📚 Unity5 3Dゲーム開発講座 ユニティちゃんで作る本格アクションゲーム
- 💻 C#読書会主催、Greek Alphabet Software Academy TA
- ❤️ プログラム、マンガ、料理、睡眠、妻&子供

---

# 本日のゴールについて

- 並行並列プログラミングは難しい
- きっちり説明出来るようになるのは結構理解を深める必要がある
- 正直今日聞いただけで全て分かったとはならないと思う
- それだけ難しい内容なので前提がないとそもそも会話自体がしづらい
- 間違っても良いのでそれぞれの違いが分かり、どういう時に使うかの会話が出来るようになることがゴール

---

# 今回の資料とChatGPT

- 今回の資料を作るのに一番やったことはChatGPTとの会話
- 兎に角疑問が出たら聞くことを続けていた
- 何度同じことを聞いても文句を言わないのが一番のメリットｗ
- 自分が得意なジャンル以外の知識を得るのにとても役に立った
- ChatGPTに聞いてもちらほら並行並列の使い方が間違っていた
- 特に多かったのは並行の話の中に並列が出てくること
- 何となくそもそもの集合知が間違っている気もする

---

# 並行並列の辞書的な説明

- 先ずはWikipedia上の言葉の定義から
- [並行計算](https://ja.wikipedia.org/wiki/%E4%B8%A6%E8%A1%8C%E8%A8%88%E7%AE%97)（へいこうけいさん、英: Concurrent computing）
  > 並行計算とは、複数の計算あるいはアルゴリズムを、同一期間に同時実行させつつ相互に同調（コンカレント）させて、次の期間開始までに互いに完遂させるという計算形態を意味している
- [並列計算](https://ja.wikipedia.org/wiki/%E4%B8%A6%E5%88%97%E8%A8%88%E7%AE%97)（へいれつけいさん、英語: parallel computing）
  > 並列計算は、コンピュータにおいて特定の処理をいくつかの独立した小さな処理に細分化し、複数の処理装置（プロセッサ）上でそれぞれの処理を同時に実行させることである。
- 辞書の内容を読んで、内容を把握できる人はかなり自頭の良い人。僕は無理。

---

# コラム：並行並列は単語が似すぎている

- 並行と並列は単語が似ているため、誤解しやすい
- 英語だとConcurrentとParallelでこっちで覚えるという話も聞く
- この英単語の日本語訳を見るとさらに混乱した。。

> [Concurrent](https://ejje.weblio.jp/content/concurrent):同時(発生)の、伴う、(…と)同時に起こって、共同に作用する、協力の、一致の、同意見の

> [Concurrency](https://ejje.weblio.jp/content/concurrent):同時並行

> [Parallel](https://ejje.weblio.jp/content/Parallel):平行の、(…と)平行して、(事柄など)相等しい、相似する、並行する、(…と)相似して、一致して、対応して、並列の

- 後で根本的に対応するのでお楽しみに。

---

# 並行並列のイメージ的な説明

<style>
.image-container {
  display: flex;
  justify-content: space-around;
}
</style>

- 並行処理：洗濯の最中に料理をしよう

  - 「洗濯」というタスクと、「料理」というタスクを、同時に実行。これが、並行処理。

  <div class="image-container">
      <img src="./image/Parallel/laundry.png" width="10%"><img src="./image/Parallel/cook.png" width="10%">
  </div>

- 並列処理：ふたりで片付けを済ませよう

  - 「皿洗い」というタスクを、ふたりで一緒に行う。これが、並列処理。

  <div class="image-container">
    <img src="./image/Parallel/dish.png" width="10%">
  </div>

> 引用:[【実は別物】並行と並列、プログラミングでの違いを知ろう](https://plainprogram.com/concurrency-and-parallelism/)

---

# 並行のイメージ：補足

- 並行処理：洗濯と料理は比較的１人で両方やっても効率的にやりやすいかも。
- どちらも待ちが入るポイントがあるから
- これが例えば読書とプログラミングならどうか？

---

# 並行並列のプログラム的な説明

- 並行（Concurrent）

  > 複数のタスクが同時に「実行されているように見える」状態。実際には同時に実行されていないかもしれないが、スレッドやコルーチンがタスク間を効率的に切り替えながら実行。これは、シングルプロセッサのシステムでも実現可能。

- 並列（Parallel）

  > 同時に複数のタスクを実行すること。複数のプロセッサやコアを利用して、異なるタスクを同時に実行。例えば、マルチプロセッシング（複数のプロセスを実行）やマルチスレッド（同一プロセス内で複数のスレッドを実行）によって並列処理が行われる。

---

# プロセス

- プロセスとは、OSによって管理される実行中のプログラムの単位
- プログラムが実行されると、そのプログラムはプロセスとしてOSによってメモリ空間を割り当てられる
- プロセスは他のプロセスから完全に独立しており、各プロセスはそれぞれ独自のメモリ空間（仮想メモリ）を持っている
- つまり、他のプロセスのメモリに直接アクセスすることはできない
- 異なるプロセス間でのデータのやり取りは、プロセス間通信を通じて行われる
- これには、共有メモリ、パイプ、メッセージキューなどが含まれるが、管理や通信には一定のオーバーヘッドが伴う

---

# スレッド

- プロセスの中で実行される処理の最小単位。
- 1つのプロセス内で複数のスレッドを持つことができる
- それぞれのスレッドはプロセスのリソースを共有しながら独立して動作する
- プロセスに比べて、スレッドは軽量。
- スレッド同士は同じプロセス内でメモリやリソースを共有しているため、スレッド間の切り替えや通信は、プロセス間の通信よりも高速で効率的
- 同じプロセス内のスレッドはプロセスのメモリ空間を共有している。これにより、スレッド間でのデータ共有が簡単。
- 共有リソースに対するアクセスの競合や同期を考慮する必要がある（例: ロックやミューテックスの使用）

---

# コルーチン、タスク：補足

- コルーチン（英: co-routine）とはプログラミングの構造の一種。サブルーチンがエントリーからリターンまでを一つの処理単位とするのに対し、コルーチンはいったん処理を中断した後、続きから処理を再開できる。接頭辞 co は協調を意味するが、複数のコルーチンが中断・継続により協調動作を行うことによる。C#にはない概念、Unityにはある。

- タスクは、「任務、課題」、「仕事、職務」、「役割、目的」などの意味を持つ英単語。またコンピュータ処理における仕事の単位。OSや応用範囲により意味が異なる。
  プロセスと同義。スレッドと同義。タスク並列性などの用語では両者を区別しない場合もある。Microsoft Windowsでは、アプリケーションプロセスのことをタスクと呼ぶことがある。C#にはTaskクラスがある。

- タスクも複数意味を持つので要注意キーワード。

---

# プロセスとスレッドまとめ

| 特徴                 | プロセス (Process)                                             | スレッド (Thread)                                                                |
| -------------------- | -------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| **メモリ空間**       | 独立している（他のプロセスとメモリ空間を共有しない）           | 同じプロセス内のスレッドはメモリ空間を共有                                       |
| **リソースの独立性** | 独立したリソース（ファイル、ネットワーク接続など）を持つ       | プロセスのリソースを共有                                                         |
| **コスト**           | スレッドより重い（新しいプロセスの作成や切り替えが高コスト）   | 軽量で低コスト（スレッド間の切り替えが速い）                                     |
| **データの共有**     | 他のプロセスと直接データを共有できない                         | メモリやリソースを共有し、効率的なデータ共有が可能                               |
| **実行の独立性**     | 完全に独立している（クラッシュしても他のプロセスに影響しない） | スレッドがクラッシュすると同じプロセス内の他のスレッドに影響を与える可能性がある |

---

# 並列並行のプログラム的な説明（再度）

- 並行（Concurrent）: 複数のタスクが同時に「実行されているように見える」状態を指します。実際には同時に実行されていないかもしれませんが、スレッドやコルーチンがタスク間を効率的に切り替えながら実行します。これは、シングルプロセッサのシステムでも実現可能です。

- 並列（Parallel）: 同時に複数のタスクを実行することを指します。複数のプロセッサやコアを利用して、異なるタスクを同時に実行します。例えば、マルチプロセッシング（複数のプロセスを実行）やマルチスレッド（同一プロセス内で複数のスレッドを実行）によって並列処理が行われます。

- ん？**マルチプロセスや**マルチスレッド？？

---

# プロセスとスレッドの意味は共通

- プロセスとスレッドはほぼすべてのモダンなオペレーティングシステム（OS）で共通して持っている基本的な概念。
- 各OSによってプロセスやスレッドの具体的な実装や管理方法には違いがあるが、それぞれの役割や意味は一般的に同じ。
- そう考えると並列処理はプロセスよりスレッドを使った方が絶対的に効果的

---

# 何故マルチプロセス？

- プロセスはスレッドよりも作成や切り替えが高コスト
- マルチにして処理を分けても、やった結果は何処かで戻す必要がある
- プロセスはメモリが独立している。データを共有出来ない。
- 普通に考えてファイルに書き出すよりメモリを見る方が簡易で高速
- なんでマルチプロセス？？

---

# Pythonの並行処理・並列処理

- [Pythonの並列処理・並行処理をしっかり調べてみた](https://qiita.com/simonritchie/items/1ce3914eb5444d2157ac)の中でマルチプロセスの話が出てくる。
- Pythonは言語仕様で1つのスレッドしか動かない。そのため並列処理にマルチスレッドを使っても恩恵が受けられない
- 結果Pythonでは並行処理をマルチプロセスでやる
- 制限はCPUバウンドな処理に限られ、I/Oバウンドな処理ではスレッドを使っても効率的な処理が可能なのでスレッドが使われないわけではない。

---

# 並行並列について言語ごとの違い

- C#: 非同期プログラミング（async/await）が一般的。並列処理は主にTask Parallel Library やマルチスレッドを通して行われる。
- Java: 並行処理が中心。非同期プログラミングはあるが、構文的なサポートはC#ほど強力ではない。
- Go: 並行処理が主流で、ゴルーチンを活用。非同期のキーワードはあまり使わない。
- Python: 非同期プログラミングが強調され、asyncioがよく使われる。並行処理もサポートされるが、GILの制約あり。
- JavaScript: 非同期プログラミングが中心。イベントループを使った非同期処理が非常に重要。
- Rust: 並行処理と非同期処理の両方が重要視されている。async/awaitやスレッドを使った並行処理が使われる。

## つまり並行の考え方は言語に依っても変わる部分がある

---

# 同期処理 (Synchronous Processing)

- 定義: タスクが順番に実行され、1つのタスクが完了するまで次のタスクに進まないこと。タスクは直列的に処理される。
- 例: A→B→Cの順番で処理が実行され、Aが完了しない限りBに進めない。
- 特徴: 処理が1つずつ実行されるため、シンプルで制御が容易だが、効率が悪くなることがある。
- まあ、普通に組んだら同期処理。

---

# 非同期処理 (Asynchronous Processing)

- 定義: 特定のタスクが完了を待たずに次のタスクに進むこと。あるタスクが実行中に、別のタスクが並行して進行する。
- 例: タスクAが実行中に、別のタスクBが同時に実行される可能性がある。Aが完了を待つことなくBが進行できる。
- 特徴: タスクが並行して実行されるため、効率的であり、待ち時間を最小化できる。Webリクエストなど、時間のかかる操作に頻繁に利用される。
- 非同期処理は言語に依っても実装難易度が違う。

---

# 並行/並列/同期/非同期まとめ

| 用語           | 実行方法                                   | 特徴                                                                                |
| -------------- | ------------------------------------------ | ----------------------------------------------------------------------------------- |
| **並行処理**   | 複数のタスクを**交互に少しずつ**実行       | CPUがタスクを切り替えながら実行。見かけ上は同時に動いているように見える。           |
| **並列処理**   | 複数のタスクを**同時に**実行               | 複数のCPUまたはコアを使い、真の同時実行が可能。                                     |
| **同期処理**   | タスクを**順番に**実行                     | 1つのタスクが完了するまで次のタスクに進めない。制御は容易だが効率が低いことがある。 |
| **非同期処理** | タスクの**完了を待たずに**次のタスクを進行 | タスクが並行して進行でき、効率的。I/O処理やネットワーク通信に適している。           |

---

# 混乱する話題：並行は同期では実現出来ない

- 並行は同期処理処理では実現できない
- 並行は非同期処理で実現出来るが、非同期処理でないと実現出来ないわけではない。
- 並行はマルチスレッドで実現出来るが、マルチスレッドでないと実現出来ないわけではない。

---

# 並行のメリット

## 改めてChatGPTに聞いてみた

- タスクの同時進行・ユーザー体験の向上・応答性の向上
  - I/O待ちや長時間かかる計算を含むプログラムでは、他のタスクを並行して進めることで、待ち時間を有効活用できる
- リソースの効率的利用・効率的なリソース利用
  - CPU、メモリ、I/Oなどを効率的に使用するため、待ち時間の長い操作と他の計算を並行して処理することで、全体の処理をスムーズに進められる。例えば、CPUが待機する時間を減らし、その間に別の処理を行うことが可能
- スケーラビリティの向上
  - 並行処理を使うことで、システム全体がより多くのタスクやクライアントに対応できるようになる。並行処理を効果的に活用することで、大規模なサーバーやクラウドサービスが複数のリクエストを同時に処理でき、スケーラビリティを向上する
- パフォーマンスの向上
  - マルチコアでは、並行処理を使用することで各コアで異なるタスクを同時に実行でき、処理速度を向上させることができる。単一のタスクを1つのコアに任せるよりも、複数のコアを使ってタスクを分割して並行に実行することで、全体のパフォーマンスが向上する

---

# 並行のメリットでパフォーマンス

- 並行のメリットでパフォーマンスがあげられるが、個人的な見解として、並行処理で実際の速度が上がることはない。
- 例えば玉入れをするのに、並行処理をして速度が上がるか？
- 実際に速く処理するのであれば並列処理。にもかかわらず並行処理の文脈でちらほら出てくる。
- 並行処理はどちらかというと遅くみせないためのUI/UXのテクニックだと思う。

---

# Google Chrome：補足

- Google Chromeはマルチプロセス。
- セキュリティ強化
- 安定性の向上
- 最適化されたパフォーマンス
- リソース管理
- スケーラビリティの向上
- ガベージコレクションの負担軽減

> 引用:[なぜGoogle Chromeは多くのプロセスを開いているのか？](https://jp.tab-tv.com/2675)

## 安定性、セキュリティ、リソース管理のメリット。

## パフォーマンスのメリットはほぼ並列処理の話でマルチプロセス固有の話ではなかった

---

# ここまでのまとめ

- 並行処理は複数のタスクを交互に少しずつ実行すること
- 並列処理は複数のタスクを同時に実行すること
- 並行並列はプログラム言語に依っても違いがある
- 並行処理はどちらかというと遅くみせないためのUI/UXのテクニック
- 並列処理はパフォーマンスに効く

---

# 並行並列の具体的な話

- 並行処理はどちらかというと遅くみせないためのUI/UXのテクニック、並列処理はパフォーマンスに効く
- ここからは抽象的な話よりも具体的なコードを踏まえた方が理解しやすい
- 自分の得意な言語の方がよりしっかりした説明が出来そう
- 言語は特定するがなるべく一般化したその言語だけの話にならないようには頑張る

---

# C#の並行並列

- C#では、非同期処理が多くのユースケース（特にI/O関連）に対応できるため、非同期のキーワードが頻繁に使われる。
- 並列処理は、C#で必要とされる場面が比較的少なく、特定のシチュエーションで使われるため、日常的なプログラミングではあまり強調されない。
- C#において「並行」というキーワードはあまり使われない。代わりに「非同期」というキーワードがよく使われる

---

# C#非同期並列プログラミングとパフォーマンス

- というわけで、ココからは並行並列プログラミング改め、非同期並列プログラミング
- 実際C#の書籍のタイトルでも「非同期並列」が使われる
- 特にパフォーマンスとUI/UXに特化させた観点から話す
- 先ずはパフォーマンスの用語から

---

# ターンアラウンドタイム、スループット、レスポンスタイム

- ターンアラウンドタイム（Turnaround Time）

  - ターンアラウンドタイムは、あるプロセスやタスクが開始されてから、すべての処理が完了するまでの総時間

- スループット（Throughput）

  - スループットは、一定時間内にシステムが処理できるタスクやジョブの量
  - 高いスループットは、システムが同時により多くの作業を効率よく処理できること

- レスポンスタイム（Response Time）

  - レスポンスタイムは、システムがリクエストを受けてから最初の応答を返すまでの時間
  - ユーザーから見て、システムがどれだけ「速く反応」してくれるかに関連する
  - 非同期処理や並行処理を活用して、レスポンスタイムを短縮し、ユーザー体験を向上させることができる

---

# 非同期並列で説明

- 非同期処理を使えば重い処理があってもレスポンスタイムは速くなる
- 但しターンアラウンドタイムが速くなるかは設計にも依る
- 並列処理でスループットを上げればターンアラウンドタイムが速くなることが多い

---

# レストランの具体例

- 背景: あるレストランで、複数のテーブルからの注文を受け付け、それをキッチンで調理する。

- ターンアラウンドタイム:注文が入ってから料理が完成してお客さんに提供されるまでの時間。

> 例: テーブルAからパスタの注文が入り、注文を受けてから料理が完成してテーブルに提供されるまでに30分とする。これがテーブルAの注文のターンアラウンドタイム。

- スループット:一定時間内に処理できるタスク（注文）の数。例えば、1時間あたりに何件の注文を処理できるかを示す

> 例: キッチンが1時間に5つの料理を作ることができるとすると、スループットは5料理/時間。キッチンの効率が上がれば、スループットも向上。

- レスポンスタイム :レストランの場合、注文を受けてから「注文を受け付けました」と最初に伝えられるまでの時間がレスポンスタイム。

> 例: ウェイターが注文を取ってから、キッチンに注文が伝わり、「オーダーが受け付けられました」という確認が返ってくるまでに2分かかったとする。これがレスポンスタイム。

---

# レストランの具体例

- 例えば複数の注文が来た場合、同期的にやれば2つ目の料理が完成するには1つ目の料理が完成している必要がある
- ターンアラウンドタイムは料理1の時間 + 料理2の時間
- 料理1のレスポンスタイムはすぐだが、 料理2のレスポンスタイムは料理1が終わってからになる
- 同期処理はスループットは1

---

# レストランの並列処理

- 一番簡単な高速化はスループットを2に上げること。2人でやれば料理は別々に作れる
- ターンアラウンドタイムは料理1と料理2で料理に時間がかかった方になる
- 2つ目の料理のレスポンスタイムもターンアラウンドタイムもそれぞれの時間で済むので速くなる
- 1つ目の料理のレスポンスタイムは変わらないが、レストランは料理1つを作ることが目的ではないのであまり意味はない
- これが並列処理なのでスループットは2

---

# レストランの並行処理

- さて、これを並行処理でやろうとすると1人2つの料理をするので同時進行がカギになる
- 少なくとも同期処理は止めたいので、まず非同期処理にしてマルチスレッドで作業する。
- これで2つ目のレスポンスタイムは縮められる。
- たとえ非同期にしても例えばサラダとメインを同時に作るのは難しい。
- 並列処理でスループットを上げるのは結構難しい。
- 例えば火入れみたいなタイミングで上手く並列化するとスループットが上がってターンアラウンドタイムは早く出来るかも
- でも非同期にしていれば、例えばオーブンに入れておいて、後どれぐらいかかるかを伝えることが出来る
- 非同期処理はこういう使い方をするのが現実的

---

# パフォーマンスが遅いとは

- もう少し具体的にパフォーマンスの観点から考えてみる
- 遅さを感じるポイントは2つある
- 1つはターンアラウンドタイム。ゲームで読み込みまで1分かかればそれは遅いと感じる。
- もう1つはレスポンスタイム。アクションに対してリアクションがなかったら遅いと感じる。
- レスポンスタイムは結構シビアで一般的に3秒間リアクションがないと人は不安を感じるらしい

---

# 遅い処理があった場合

- UIにおいて、時間がかかっても良いコントロールと良くないコントロールがある
- DEMO

---

# 遅い処理があった場合

- 個人的にボタンは時間がかかっても良い数少ないコントロール
- 遅くて良い場所に重い処理をまとめる
- ただし、そうであっても待てる時間は限界がある

---

# 遅い処理があった場合

- 押したら押せない状態にする
- DEMO
- アニメーションするとより待てる
- DEMO

---

# 遅い処理があった場合

- この対応でも悪くはないが、圧倒的な問題として操作すると固まる
- UIが固まらなくなる対応はマルチスレッドで対応
- DEMO

---

# 遅い処理があった場合

- UIコンポーネントの制限としてUIスレッド以外からの書き込むと例外が出る
- DEMO

---

# 遅い処理があった場合

- UIスレッドでの書き込みをする方法は幾つかかあるがここは意識しないといけない
- DEMO

---

# async, await

- C#5.0で発表された新しい非同期プログラミング
- 当時あまりにセンセーショナルで永遠の忠誠を誓った記憶があるｗ
- 今では他の言語にも派生している。JavaScriptでも可能
- 個人的にはasyncいるかなと思ったけれど常識になってしまった

---

# 非同期処理

- async,awaitは書き方は意外とシンプル
- ただし注意点はあり
- 上手く使えば手軽にかなり効果的に使える

---

# 非同期処理

- これで並行処理で非同期が実装出来た。
- 並行処理で2つ同時に作業は出来る。
- ただ、何度も言っているがこれで高速化は難しい
- これで高速化出来るならシングルスレッドでも出来る。
- さらに言うと、データの同期を取るのにロックが必要になる
- ロックするとさらにパフォーマンスにデメリットがある

---

# 非同期処理

- パフォーマンスの観点で言えば、非同期でレスポンスタイムを上げることは出来る
- それによりUIでの表現を工夫して遅い処理にストレスを感じさせない努力こそ必要

---

# 並列処理

- その他の並列処理
- SIMD
- GPU

---
